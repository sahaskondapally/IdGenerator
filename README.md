Solution Overview 

The SequenceGenerator algorithm generates unique tracking numbers by combining a timestamp, a node identifier, and a sequence number. The design ensures that IDs are unique, scalable, efficient, and fault-tolerant. The algorithm is built around the concept of a unique identifier with specific bit allocations for different components. 

Key Components 

Timestamp 

Node ID 

Sequence Number 

Algorithm Steps 

Initialization: 

Epoch Definition: Define a custom epoch starting at January 1, 2024. This is the reference point from which timestamps are calculated. 

Bit Allocation: The unique ID is structured with specific bits allocated for each component: 

Timestamp: 64 bits 

Node ID: 30 bits 

Sequence Number: 12 bits 

Generate a Node ID: 

Retrieve System Information: Obtain network-related information from the local system, such as hostname, IP address, and MAC address. 

Generate Node ID: Combine this information to create a unique node identifier. If this process fails, use a random number generator to create a fallback node ID. 

Generate a Unique ID: 

Timestamp Calculation: Calculate the current timestamp in milliseconds since the custom epoch. 

Check Timestamp Validity: Compare the current timestamp with the last generated timestamp: 

If the current timestamp is earlier than the last timestamp, an error is raised indicating an invalid system clock. 

If the current timestamp is the same as the last timestamp, the sequence number is incremented. If the sequence number overflows (i.e., reaches its maximum value), wait for the next millisecond. 

If the current timestamp is later than the last timestamp, reset the sequence number to zero. 

Wait for Next Millisecond: 

Check for Overflow: If the sequence number has reached its maximum value within the same millisecond, block and wait until the timestamp changes (i.e., wait for the next millisecond). This ensures that the sequence number resets and avoids collisions. 

Construct the ID: 

Combine Components: 

High Part: Use the timestamp as the high part of the ID. 

Low Part: Combine the node ID and sequence number into the low part of the ID. 

Format the ID: Convert both parts into a hexadecimal string and concatenate them to form the final unique ID. 

Return the Unique ID: 

Format the Output: Return the concatenated hexadecimal string representing the unique ID. 

Summary of Operations 

Retrieve System Information: For generating a unique node ID. 

Calculate Timestamp: Determine the current time relative to the custom epoch. 

Check and Manage Sequence Number: Ensure uniqueness by handling sequence number overflow and waiting for the next millisecond if necessary. 

Construct and Format ID: Combine the timestamp, node ID, and sequence number, and format the result as a hexadecimal string. 

Fault Tolerance 

Invalid Clock Handling: If the system clock is not functioning correctly (i.e., current timestamp is earlier than the last timestamp), an exception is thrown to indicate a problem. 

Fallback for Node ID Generation: If network information is not available, a random node ID is used to ensure that the process can still generate unique IDs. 

Scalability and Efficiency 

Concurrent Handling: By synchronizing access to the sequence number and handling millisecond boundaries, the algorithm supports high concurrency and ensures that IDs are generated efficiently without bottlenecks. 

Horizontal Scaling: The use of node IDs ensures that multiple instances of the generator can run across different machines, all generating unique IDs without conflict. 

This algorithm effectively ensures that each tracking number generated is unique, even when multiple generators are running concurrently across different systems. 

 

 

Bit Mapping Explanation 

The SequenceGenerator uses a bitwise approach to structure the unique ID with 128 bit. This involves allocating specific numbers of bits to different parts of the ID to ensure its uniqueness and efficiency. Here's a breakdown of the bit allocation: 

Bit Fields 

Timestamp Bits (64 bits) 

Purpose: Represents the time elapsed since a custom epoch. 

Bits Used: 64 bits 

Range: Allows for a very large range of timestamps, providing uniqueness over a long period. With 64 bits, you can represent a vast range of milliseconds. 

Node ID Bits (30 bits) 

Purpose: Identifies the node (or machine) that generated the ID. 

Bits Used: 30 bits 

Range: This provides up to 230−12^{30} - 1230−1 unique node IDs (1,073,741,823 possible node IDs). This ensures that IDs generated by different nodes do not conflict. 

Sequence Bits (12 bits) 

Purpose: Tracks the sequence of IDs generated within the same millisecond by a single node. 

Bits Used: 12 bits 

Range: Allows for 2122^{12}212 (4,096) unique sequence values per millisecond. This ensures that even if multiple IDs are generated within the same millisecond, they remain unique. 

Unused Bits (22 bits) 

Purpose: Reserved for future expansion or for additional purposes, such as error checking or other metadata. 

Bits Used: 22 bits 

Range: Not used in the current implementation but reserved to ensure that the ID structure can accommodate future changes or additional fields. 

ID Structure 

The overall structure of the ID is a 64-bit value, divided into: 

High Part (Timestamp): Contains the timestamp and is the higher 64 bits of the ID. 

Low Part (Node ID + Sequence): Contains the node ID and sequence number, packed into the lower bits of the ID. 

Detailed Breakdown 

High Part (64 bits): 

Timestamp (64 bits): Represents the time in milliseconds since a custom epoch (January 1, 2024). This large range ensures that IDs are unique over an extended period. 

Low Part (64 bits): 

Node ID (30 bits): Positioned in the most significant 30 bits of the low part. 

Sequence (12 bits): Positioned in the least significant 12 bits of the low part. 

Example: 

css 

Copy code 

[ Timestamp (64 bits) | Node ID (30 bits) | Sequence (12 bits) ] 
